from numpy.linalg import inv as np_inv
from numpy.linalg import svd, det, cholesky
# from numpy.linalg import slogdet as np_slogdet
from numpy import array, trace, log, diag
from numpy import sqrt as np_sqrt
from scipy.linalg import sqrtm
from scipy.optimize import bisect, brenth, minimize_scalar, LinearConstraint, minimize
import numpy as np
import sys
from fpylll import *
from fpylll.algorithms.bkz2 import BKZReduction
from sage.matrix.constructor import vector_on_axis_rotation_matrix



ROUNDING_FACTOR = 2**64

def round_matrix_to_rational(M):
    A = matrix(ZZ, (ROUNDING_FACTOR * matrix(M)).apply_map(round))
    return matrix(QQ, A / ROUNDING_FACTOR)

def projection_matrix(A):
    """
    Construct the projection matrix orthogonally to Span(V)
    """
    S = A * A.T
    return A.T * S.inverse() * A

# Convert a 1*1 matrix into a scalar
def scal(M):
    assert M.nrows() == 1 and M.ncols() == 1, "This doesn't seem to be a scalar."
    return M[0, 0]

# Finds the square root of a matrix and its inverse as well
def square_root_inverse_degen(S, B=None, assume_full_rank=False):
    """ Compute the determinant of a symmetric matrix
    sigma (m x m) restricted to the span of the full-rank
    rectangular (k x m, k <= m) matrix V
    """
    
    if assume_full_rank:
        P = identity_matrix(S.ncols())

    elif not assume_full_rank and B is None:
        # Get an orthogonal basis for the Span of B
        V = S.echelon_form()
        V = V[:V.rank()]
        P = projection_matrix(V)

    else:
        P = projection_matrix(B)

    # make S non-degenerated by adding the complement of span(B)
    C = identity_matrix(S.ncols()) - P
    # Take matrix sqrt via SVD, then inverse
    # S = adjust_eigs(S)
    
    u, s, vh = svd(array(S + C, dtype=float))
    L_inv = np_inv(vh) @ np_inv(np_sqrt(diag(s))) @ np_inv(u)
    # L_inv = np_inv(sqrtm(array(S + C, dtype=float)))
    
    L_inv = np_inv(cholesky(array(S + C, dtype=float))).T
    L_inv = round_matrix_to_rational(L_inv)
    L = L_inv.inverse()


    # scipy outputs complex numbers, even for real valued matrices. Cast to real before rational.
    #L = round_matrix_to_rational(u @ np_sqrt(diag(s)) @ vh)

    return L, L_inv

def mie_unit_ball(alpha, beta, dim):
    alpha, beta = min(alpha,beta), max(alpha,beta)
    alpha, beta = max(alpha, -1), min(beta, 1)

    # this is a and b in the paper, changed names to avoid confusion
    matrix_first, matrix_rest, tau = 0, 0, 0
    n = dim
    left_condition = 4 * n * (1 - alpha) * (1 + alpha)
    right_condition = (n + 1) * (n + 1) * (beta - alpha) * (beta + alpha)

    if alpha == -beta:
        tau = 0
        matrix_first = beta
        matrix_rest = 1
    elif left_condition < right_condition:
        intermediate = sqrt(alpha ** 2 + left_condition / ((n+1) ** 2))
        tau = 0.5 * (alpha + intermediate)
        matrix_first = tau - alpha
        matrix_rest = sqrt(matrix_first * (matrix_first + n * tau))
    else: # (left_condition >= right_condition)
        denom = 2 * (sqrt((1 - alpha) * (1 + alpha)) - sqrt((1 - beta) * (1 + beta)))
        tau = 0.5 * (beta + alpha)
        matrix_first = 0.5 * (beta - alpha)
        matrix_rest = sqrt(matrix_first ** 2 + ((beta ** 2 - alpha ** 2) / denom) ** 2)


    # this is to build up the diagonal matrix as in the paper (LINK PAPER HERE)
    z = zero_vector(RR, n)
    z[0] = matrix_first
    for ind in range(1, n):
        z[ind] = matrix_rest
    A = diagonal_matrix(z)
    c = zero_vector(RR, n)
    c[0] = tau
    c = c.row()
    return A, c

def create_2d_plot(mie, direction, a, b):
    from copy import deepcopy
    
    # Add the lines
    major_axis_length = sqrt(mie.S.columns(0)[0][0]^2 + mie.S.columns(0)[0][1]^2)
    norm = sqrt(direction[0][0]^2 + direction[0][1]^2)
    unit_direction = direction/norm
    
    # Find the 2 points that are a distance of 'a' and 'b' away from the center
    first_center = unit_direction * a + mie.mu
    second_center = unit_direction * b + mie.mu

    # Find the points that are far away from the first and second centers in the direction of the parallel cuts.
    distance_from_center = vector(RR, [-direction[0][1], direction[0][0]]).row() * major_axis_length/norm
    
    first_line = list(first_center + distance_from_center)
    first_line.append(list(first_center - distance_from_center)[0])
    
    second_line = list(second_center + distance_from_center)
    second_line.append(list(second_center - distance_from_center)[0])
    
    # Integrate parallel cuts
    old_mie = deepcopy(mie)
    mie.integrate_parallel_cuts_hint(direction, a,b)

    p = old_mie.plot2d(1) + mie.plot2d(0)
    
    
    p += line(first_line, color = "deepskyblue")
    p += line(second_line, color = "deepskyblue")


    return p


# From the papers:
# intuitive form of ellipse: E = {c + Au : u in B_n}
# ellipoid norm form:        E = {x in R^n : <X(x-c), x-c> <= 1}
# Here, X = Sigma^(-1), and A = X^(-1/2) = Sigma^(1/2)


class MIE:
    def __init__(self, S, mu):
        # check out how Hunter did this check
        if not np.all(np.linalg.eigvals(S) >= 0):
            raise Exception("ERROR: must input a positive semidefinite matrix")
        self.S = S
        self.mu = mu

    def dim(self):
        return len(list(self.mu.transpose()))

    # WARNING: this is done assuming that self.S is in the intiuitve form
    def plot2d(self, colorValue):
        p = plot([], aspect_ratio = 1)
        (sqrt_mat, sqrt_inv_mat) = square_root_inverse_degen(self.S)
        # Since the ellipse is of the form A*Ball + self.mu, we can plot the ellipse by 
        # plotting where the points of a circle map to.
        for ind in range(0,360):
            original_point = vector(RR, [cos(ind), sin(ind)]).row()
            
            # Why no transpose here??
            new_point = original_point * sqrt_mat
            new_point += self.mu
            colorVal = "black" if colorValue == 1 else "magenta"
            p2 = point(new_point,color=colorVal)
            p += p2
        return p
        
    # NOTE: in the toolkit everything is done with rows instead of columns
    # go about this assuming direction is a unit vector from now on,
    # this matches the definition of what one expects when working with a
    # "direction" vector

    # but the user need not worry about this, we'll normalize it
    
    def integrate_parallel_cuts_hint(self, direction, a, b):
        if (a == b):
            print("Invalid Hint")
            return
        # the meaning of the signs here is kind of superfluous, this is just
        # to determine where everything is relative to the center of the
        # ellipsoid
        
        # a and b are distances from the center of the ellipsoid to the
        # two hyperplanes in the hint, along the direction of direction

        # now a and b are vectors representing the center of the ellipse
        # to the hyperplanes
        
        direction = direction / direction.norm()

        # there are problems if the direction is not in the column space
        # right now just error out
        try:
            self.S.solve_left(a * direction)
            self.S.solve_left(b * direction)
        except:
            print("a or b along direction not in column space of Sigma")
            return

        (sqrt_mat, sqrt_inv_mat) = square_root_inverse_degen(self.S)

        # this is to accommodate for step 2 in our drawing
        # Step 2: stretch the ellipsoid into ball
        # before: E = (sqrt_mat)B_n
        # after: E = B_n
        # to get back to a ball for easy rotations, we must "stretch"
        # the ellipsoid back into a ball, which is done by
        # multiplying by sqrt_inv_mat to undo sqrt_mat

        direction = direction * sqrt_inv_mat
        a_scaled = a * direction
        b_scaled = b * direction
        
        direction = direction/direction.norm()

        rot_mat = vector_on_axis_rotation_matrix(vector(RR, direction.list()), 0)
        inv_rot_mat = matrix(RR, fractional_matrix_power(rot_mat, -1))


        # Step 3: rotate the ball such that a_scaled and b_scaled are in
        # the direction of the x axis
        # before: E = B_n
        # after: E = B_n (rotated in some way)

        a_scaled_rot = a_scaled * rot_mat.transpose()
        b_scaled_rot = b_scaled * rot_mat.transpose()

        alpha = a_scaled_rot[0][0]
        beta = b_scaled_rot[0][0]
        A, c = mie_unit_ball(alpha, beta, self.dim())

        
        
        # transform it back and mutate the starting matrix
        A = inv_rot_mat * A
        print(A)
        
        # Dana mentioned that we might want self.S to be of the form
        # inv_sqrt_mat * S * sqrt_mat
        # because of the properties that we have
        # xSx^T <= 1 (perhaps in order to mirror this property we would have
        #    (x * sqrt_inv_mat) * S * (x * sqrt_inv_mat)^T
        # <=> x * (sqrt_inv_mat * S * inv_mat) * x^T
        
        a_s = A.transpose() * sqrt_mat
        self.S = a_s.transpose() * a_s 
        # apply sqrt_inv to c
        c = c * inv_rot_mat.transpose()
        c = c * sqrt_mat
        self.mu += c
        print(self.S)
m = MIE(matrix(RR, [[4, 0], [0, 1]]), vector(RR, [0,0]).row())
create_2d_plot(m, vector(RR, [sqrt(2), sqrt(2)]).row(), -.5, .5)
